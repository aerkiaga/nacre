// A type for Peano arithmetic using Church numerals
let Church = type(T: Type, f: T -> T, x: T) -> T;
let Church::0 = fn(T: Type, f: T -> T, x: T) x;
let Church::s = fn(self: Church) {
    fn(T: Type, f: T -> T, x: T) {
        f (self T f x)
    }
};

// An enum with two variants
let Bool = type(T: Type, a: T, b: T) -> T;

// An enum with two variants, where one of them contains data of type A
let Option = fn(A: Type) type(T: Type, a: A -> T, b: T) -> T;

// A linked list containing inner type A
let List = fn(A: Type) type(T: Type, f: T -> A -> T, x: T) -> T;
let List::new = fn(A: Type) {
    fn(T: Type, f: T -> A -> T, x: T) x
};
let List::push_back = fn(A: Type) fn(self: List A, element: A) {
    fn(T: Type, f: T -> A -> T, x: T) {
        f (self T f x) A
    }
};
let List::push_front = fn(A: Type) fn(self: List A, element: A) {
    fn(T: Type, f: T -> A -> T, x: T) {
        self T f (f x A)
    }
};
let List::map = fn(A: Type, B: Type) fn(self: List A, f: A -> B) {
    let mapper = fn(r: List, a: A) {
        List::push_back(r, a)
    };
    self (List B) mapper List::new
};

// A struct containing members A and B
let Pair = fn(A: Type, B: Type) type(T: Type, f: A -> B -> T) -> T
