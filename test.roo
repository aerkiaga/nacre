// A type for Peano arithmetic using Church numerals
let Church = type(T: Type, f: T -> T, x: T) -> T;
let Church::0 = fn(T: Type, f: T -> T, x: T) {x};
let Church::s = fn(self: Church) {
    fn(T: Type, f: T -> T, x: T) {
        f (self T f x)
    }
};

// An enum with two variants
let Bool = type(T: Type, a: T, b: T) -> T;

// An enum with two variants, where one of them contains data of type A
let Option = fn(A: Type) {
    type(T: Type, a: A -> T, b: T) -> T
};

// A struct containing members A and B
let Pair = fn(A: Type, B: Type) {
    type(T: Type, f: A -> B -> T) -> T
};

// A linked list containing inner type A
let List = fn(A: Type) {
    type(T: Type, f: T -> A -> T, x: T) -> T
};
let List::new = fn(A: Type) {
    fn(T: Type, f: T -> A -> T, x: T) {x}
};
let List::push_back = fn(A: Type)(self: List A, element: A) {
    fn(T: Type, f: T -> A -> T, x: T) {
        f (self T f x) A
    }
};
let List::push_front = fn(A: Type)(self: List A, element: A) {
    fn(T: Type, f: T -> A -> T, x: T) {
        self T f (f x A)
    }
};
let List::map = fn(A: Type, B: Type)(self: List A, f: A -> B) {
    let mapper = fn(r: List, a: A) {
        let new_element = f a;
        List::push_back B r new_element
    };
    self (List B) mapper List::new B
};
let List::filter = fn(A: Type)(self: List A, f: A -> Bool) {
    let filter_fn = fn(r: List A, a: A) {
        let do_append = f A;
        let if_true = fn(r: List A) {List::push_back A r a};
        let if_false = fn(r: List A) {r};
        do_append (List A) if_true if_false
    };
    self (List A) filter_fn List::new A
}
