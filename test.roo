// The unit type, with a single inhabitant
type Unit(T: Type, t: T) -> T;

// An enum with two variants
type Bool(T: Type, a: T, b: T) -> T;

impl Bool {
    fn true(T: Type, a: T, b: T) {a};
    
    fn false(T: Type, a: T, b: T) {b};
    
    fn not(self: Bool) {
        self Bool Bool::false Bool::true
    } -> Bool;
    
    fn and(self: Bool, other: Bool) {
        self Bool other Bool::false
    };
    
    fn or(self: Bool, other: Bool) {
        self Bool Bool::true other
    };
    
    fn xor(self: Bool, other: Bool) {
        self Bool (Bool::not other) other
    }
};

// An enum with two variants, where one of them contains data of type A
fn Option(A: Type) {
    type(T: Type, a: A -> T, b: T) -> T
};

impl Option {
    fn some(A: Type)(inner: A) {
        fn(T: Type, a: A -> T, b: T) {
            a inner
        }
    };
    
    fn none(A: Type)(T: Type, a: A -> T, b: T) {
        b
    };
    
    fn map(A: Type, B: Type)(self: Option A, mapper: A -> B) {
        fn a(inner: A) {
            Option::some B (mapper inner)
        };
        let b = Option::none B;
        self (Option B) a b
    }
};

// A struct containing members A and B
fn Pair(A: Type, B: Type) {
    And A B
    // Expands to:
    //type(T: Type, f: A -> B -> T) -> T
};

// A type for Peano arithmetic using Church numerals
type Church(T: Type, f: T -> T, x: T) -> T;

impl Church {
    fn 0(T: Type, f: T -> T, x: T) {x};
    
    fn s(self: Church) {
        fn(T: Type, f: T -> T, x: T) {
            f (self T f x)
        }
    };
    
    fn add(self: Church, other: Church) {
        self Church Church::s other
    };
    
    fn mul(self: Church, other: Church) {
        self Church (other Church Church::s) Church::0
    }
    /* Cannot define induction principle in CoC */
};

// A linked list containing inner type A
fn List(A: Type) {
    type(T: Type, f: T -> A -> T, x: T) -> T
};

impl List {
    fn new(A: Type) {
        fn(T: Type, f: T -> A -> T, x: T) {x}
    };
    
    fn push_back(A: Type)(self: List A, element: A) {
        fn(T: Type, f: T -> A -> T, x: T) {
            f (self T f x) element
        }
    };
    
    fn push_front(A: Type)(self: List A, element: A) {
        fn(T: Type, f: T -> A -> T, x: T) {
            self T f (f x element)
        }
    };
    
    fn map(A: Type, B: Type)(self: List A, f: A -> B) {
        fn mapper(r: List B, a: A) {
            let new_element = f a;
            List::push_back B r new_element
        };
        self (List B) mapper (List::new B)
    };
    
    fn filter(A: Type)(self: List A, f: A -> Bool) {
        fn filterer(r: List A, a: A) {
            let do_append = f a;
            let if_true = List::push_back A r a;
            let if_false = r;
            do_append (List A) if_true if_false
        };
        self (List A) filterer (List::new A)
    }
}
