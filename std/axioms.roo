let Eq = super::logic::Eq;
let Eq::reflexive = super::logic::Eq::reflexive;
let Not = super::logic::Not;
let Or = super::logic::Or;
let Church = super::super::test::Church;

type ExcludedMiddle(P: Type) -> Or P (Not P): Type;

/*
Since Rooster uses a single sort for
both propositions and data types,
proof irrelevance is inconsistent.

Since excluded middle + functional choice
implies proof irrelevance, functional choice
must be false if excluded middle is true.

Uniqueness of proofs must be axiomatized
in a case by case basis, so it cannot apply
to types that carry information.
*/

type StreicherK(A: Type, x: A)(P: Eq A x x -> Type) ->
    P (Eq::reflexive A x) -> type(p: Eq A x x) -> P p: Type;

type UniquenessOfIdentityProofs(A: Type, x: A, y: A)
    (p1: Eq A x y, p2: Eq A x y) -> Eq (Eq A x y) p1 p2: Type;

type UniquenessOfReflexivityProofs(A: Type, x: A)
    (p: Eq A x x) -> Eq (Eq A x x) p (Eq::reflexive A x): Type;

impl UniquenessOfReflexivityProofs {
    fn from_streicher_k(sk: StreicherK) {
        fn(A: Type, x: A) {
            let x_refl = Eq::reflexive A x;
            fn equals_refl(h: Eq A x x) {
                Eq (Eq A x x) h x_refl
            };
            let trivial_case = Eq::reflexive (Eq A x x) x_refl;
            sk A x equals_refl trivial_case
        }
    } -> UniquenessOfReflexivityProofs;
}
