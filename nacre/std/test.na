// The unit type, with a single inhabitant
type Unit(T: Type, t: T) -> T: Type;

// An enum with two variants
type Bool(T: Type, a: T, b: T) -> T: Type;

impl Bool {
    fn true(T: Type, a: T, b: T) {a}: Bool;
    
    fn false(T: Type, a: T, b: T) {b}: Bool;
    
    fn not(self: Bool) {
        self Bool::false Bool::true
    } -> Bool;
    
    fn and(self: Bool, other: Bool) {
        self other Bool::false
    } -> Bool;
    
    fn or(self: Bool, other: Bool) {
        self Bool::true other
    } -> Bool;
    
    fn xor(self: Bool, other: Bool) {
        self other.not other
    } -> Bool;
};

// An enum with two variants, where one of them contains data of type A
fn Option(A: Type) {
    type(T: Type, a: A -> T, b: T) -> T
} -> Type;

impl Option {
    fn some(A: Type)(inner: A) {
        fn(T: Type, a: A -> T, b: T) {
            a inner
        }
    } -> Option A;
    
    fn none(A: Type) {
        fn(T: Type, a: A -> T, b: T) {
            b
        }
    } -> Option A;
    
    fn map(A: Type)(self: Option A)(B: Type)(mapper: A -> B) {
        fn a(inner: A) {
            Option::some (mapper inner)
        };
        let b = Option::none B;
        self a b
    } -> Option B;
};

// A struct containing members A and B
fn Pair(A: Type, B: Type) {
    //And A B
    type(T: Type, f: A -> B -> T) -> T
} -> Type;

// A type for Peano arithmetic using Church numerals
type Church(T: Type, f: T -> T, x: T) -> T: Type;

impl Church {
    fn 0(T: Type, f: T -> T, x: T) {x}: Church;
    
    fn s(self: Church) {
        fn(T: Type, f: T -> T, x: T) {
            f (self f x)
        }
    } -> Church;
    
    fn add(self: Church, other: Church) {
        self Church::s other
    } -> Church;
    
    fn mul(self: Church, other: Church) {
        self (other Church::s) Church::0
    } -> Church;
    /* Cannot define induction principle in CoC */
};

// A linked list containing inner type A
fn List(A: Type) {
    type(T: Type, f: T -> A -> T, x: T) -> T
} -> Type;

impl List {
    fn new(A: Type) {
        fn(T: Type, f: T -> A -> T, x: T) {x}
    } -> List A;
    
    fn push_back(A: Type)(self: List A, element: A) {
        fn(T: Type, f: T -> A -> T, x: T) {
            f (self f x) element
        }
    } -> List A;
    
    fn push_front(A: Type)(self: List A, element: A) {
        fn(T: Type, f: T -> A -> T, x: T) {
            self f (f x element)
        }
    } -> List A;
    
    fn map(A: Type)(self: List A)(B: Type)(f: A -> B) {
        fn mapper(r: List B, a: A) {
            let new_element = f a;
            r.push_back new_element
        };
        self mapper (List::new B)
    } -> List B;
    
    fn filter(A: Type)(self: List A, f: A -> Bool) {
        fn filterer(r: List A, a: A) {
            let do_append = f a;
            let if_true = r.push_back a;
            let if_false = r;
            do_append if_true if_false
        };
        self filterer (List::new A)
    } -> List A;
};
